#!/usr/bin/env -S jq -s -f
import "xor_table" as $XOR; # generated by running the xor from day17p1 with 
# reduce (range(256) as $a | range(256) as $b | [$a, $b]) as [$a, $b] ([]; setpath([$a, $b]; xor($a; $b)))

# the bitwise operators here are faster than those in day17p1 since we
# precompute the xor for every byte pairing, so our xor implemntation can work
# by byte (and, instead of a shift with the expensive decimal->binary
# conversion, we just do a divide)

# still, this isn't particularly efficient, it takes a little less than two minutes on my machine

def xor($a; $b):
    [1, 0, $a, $b]
    | until(.[-1] == 0 and .[-2] == 0;
        . as [$mul, $res, $a, $b]
        | ($a % 256) as $a_rem
        | ($b % 256) as $b_rem
        | [$mul * 256, $res + $mul * $XOR[0][$a_rem][$b_rem], ($a - $a_rem) / 256, ($b - $b_rem) / 256])
    | .[1];

def prune:
    . % 16777216;

def repeat(f; $times):
    [0, .]
    | until(.[0] == $times;
        .[0] as $i | .[1] | f | [$i + 1, .])
    | .[1];

def div($a; $b):
    ($a % $b) as $rem
    | ($a - $rem) / $b;

def next:
    xor(.; . * 64) | prune
    | xor(.; div(.; 32)) | prune
    | xor(.; . * 2048) | prune;

. | map(repeat(next; 2000)) | add
